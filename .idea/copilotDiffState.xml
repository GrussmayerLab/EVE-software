<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/EXPLORE_TAB_POINT_SELECTION_FIX.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/EXPLORE_TAB_POINT_SELECTION_FIX.md" />
              <option name="updatedContent" value="# Explore Tab Point Selection Fix&#10;&#10;## Summary&#10;Fixed the point selection and cluster highlighting functionality in the Explore tab. The previous implementation used `button_press_event` which doesn't work properly for 3D matplotlib plots. This has been replaced with a proper picking mechanism.&#10;&#10;## Changes Made&#10;&#10;### 1. Updated `setup_3d_viewer()` (line ~5518)&#10;- **Changed**: Replaced `button_press_event` with `pick_event` for better 3D interaction&#10;- **Added**: `scatter_plots` dictionary to track scatter plot references for picking&#10;- **Why**: Pick events are specifically designed for selecting points in plots, providing accurate point selection even in 3D space&#10;&#10;### 2. Updated `render_point_cloud()` (line ~5679)&#10;- **Changed**: Added `picker=True` and `pickradius=5` to all scatter plot calls&#10;- **Added**: Store DataFrame indices on each scatter plot object for later retrieval&#10;- **Why**: Enables matplotlib's picking mechanism and allows us to map picked points back to the original data&#10;&#10;### 3. Replaced `on_canvas_click()` with `on_pick()` (line ~5741)&#10;- **New Method**: `on_pick(event)` - Properly handles 3D pick events&#10;- **How it works**:&#10;  1. When user clicks near a point, matplotlib fires a pick event&#10;  2. The method identifies which scatter plot was clicked&#10;  3. Retrieves the DataFrame index of the selected point&#10;  4. Looks up the cluster ID from the cluster mapping&#10;  5. Calls `highlight_cluster()` to show the cluster&#10;&#10;### 4. Updated `render_with_highlight()` (line ~5903)&#10;- **Changed**: Improved color scheme for highlighted clusters&#10;  - Positive events: Bright green (#00ff00) with yellow borders&#10;  - Negative events: Bright magenta (#ff00ff) with yellow borders&#10;  - Background events: Faded blue/red (alpha=0.2)&#10;- **Added**: Picking enabled on all scatter plots including highlighted ones&#10;- **Added**: Proper index tracking for highlighted scatter plots&#10;- **Why**: Makes selected clusters much more visible and allows re-selection while viewing a cluster&#10;&#10;## Key Improvements&#10;&#10;1. **Functional Point Selection**: Users can now click on points and they will be properly selected&#10;2. **Clear Visual Feedback**: Selected clusters are highlighted in bright colors with yellow borders&#10;3. **Polarity Separation**: Positive and negative events maintain different colors even when highlighted&#10;4. **Re-selection Support**: Can click on other points while viewing a highlighted cluster&#10;5. **Better Performance**: Using matplotlib's built-in picking is more efficient than manual distance calculations&#10;&#10;## Testing Recommendations&#10;&#10;1. Load data using the &quot;Load Data&quot; button&#10;2. Click on different points in the 3D plot&#10;3. Verify that:&#10;   - The cluster information panel updates&#10;   - The selected cluster is highlighted in bright green/magenta&#10;   - Other events become faded&#10;   - You can select different points while a cluster is highlighted&#10;   - The &quot;Reset View&quot; button restores the original view&#10;&#10;## Technical Notes&#10;&#10;- **Pick Radius**: Set to 5 pixels - adjust if selection feels too sensitive/insensitive&#10;- **Color Scheme**: &#10;  - Regular positive: #3498db (blue)&#10;  - Regular negative: #e74c3c (red)&#10;  - Highlighted positive: #00ff00 (bright green)&#10;  - Highlighted negative: #ff00ff (bright magenta)&#10;  - Highlight border: #ffff00 (yellow)&#10;  - Background: Same colors with alpha=0.2&#10;&#10;## Potential Future Enhancements&#10;&#10;1. Add keyboard shortcuts for navigating between clusters&#10;2. Implement lasso selection for multiple points&#10;3. Add option to export selected cluster data&#10;4. Show cluster bounding box or convex hull&#10;5. Add zoom-to-cluster functionality&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/HyperParameterSearch/example_optuna_usage.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/HyperParameterSearch/example_optuna_usage.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Example script demonstrating how to use Optuna-based Bayesian optimization&#10;for hyperparameter search in EVE's candidate finding algorithms.&#10;&#10;This script shows two approaches:&#10;1. Sequential optimization (recommended for most cases)&#10;2. Parallel optimization across methods (for faster results)&#10;&quot;&quot;&quot;&#10;&#10;import numpy as np&#10;import sys&#10;import os&#10;&#10;# Add parent directory to path&#10;sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))&#10;&#10;from HyperParameterSearch.findingSearch import preview_run_optuna&#10;&#10;# Example: Load your event data&#10;# npy_array should be a structured numpy array with fields: x, y, p, t&#10;# Example format:&#10;# npy_array = np.load('your_event_data.npy')&#10;&#10;# Example settings dictionary (adjust based on your EVE configuration)&#10;settings = {&#10;    'max_parallel': 8,  # Limit parallel processes&#10;    # Add other EVE settings as needed&#10;}&#10;&#10;# Example 1: Sequential optimization (default, shows progress)&#10;def example_sequential(npy_array, settings):&#10;    &quot;&quot;&quot;&#10;    Run Optuna optimization sequentially through all methods.&#10;    This is recommended for most use cases as it provides clear progress updates.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Example 1: Sequential Optuna Optimization&quot;)&#10;    print(&quot;-&quot; * 60)&#10;    &#10;    best_method, best_params = preview_run_optuna(&#10;        npy_array=npy_array,&#10;        settings=settings,&#10;        time_stretch=None,      # Optional: (start_ms, duration_ms)&#10;        xy_stretch=None,        # Optional: (min_x, max_x, min_y, max_y)&#10;        n_trials=200,           # Number of trials per method (default: 200)&#10;        n_jobs=1                # Sequential processing&#10;    )&#10;    &#10;    return best_method, best_params&#10;&#10;&#10;# Example 2: Parallel optimization across methods&#10;def example_parallel(npy_array, settings):&#10;    &quot;&quot;&quot;&#10;    Run Optuna optimization in parallel across different methods.&#10;    This is faster but provides less visibility into progress.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Example 2: Parallel Optuna Optimization&quot;)&#10;    print(&quot;-&quot; * 60)&#10;    &#10;    best_method, best_params = preview_run_optuna(&#10;        npy_array=npy_array,&#10;        settings=settings,&#10;        time_stretch=None,&#10;        xy_stretch=None,&#10;        n_trials=200,&#10;        n_jobs=4                # Use 4 parallel jobs (adjust based on CPU cores)&#10;    )&#10;    &#10;    return best_method, best_params&#10;&#10;&#10;# Example 3: Optimization on a subset of data&#10;def example_subset(npy_array, settings):&#10;    &quot;&quot;&quot;&#10;    Run Optuna optimization on a temporal and spatial subset of the data.&#10;    This is useful for faster testing on representative data.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Example 3: Optuna Optimization on Data Subset&quot;)&#10;    print(&quot;-&quot; * 60)&#10;    &#10;    best_method, best_params = preview_run_optuna(&#10;        npy_array=npy_array,&#10;        settings=settings,&#10;        time_stretch=(0, 1000),         # First 1000ms of data&#10;        xy_stretch=(0, 100, 0, 100),    # 100x100 pixel region&#10;        n_trials=100,                    # Fewer trials for quick testing&#10;        n_jobs=1&#10;    )&#10;    &#10;    return best_method, best_params&#10;&#10;&#10;# Example 4: Quick test with fewer trials&#10;def example_quick_test(npy_array, settings):&#10;    &quot;&quot;&quot;&#10;    Quick optimization with fewer trials for rapid prototyping.&#10;    &quot;&quot;&quot;&#10;    print(&quot;Example 4: Quick Optuna Test&quot;)&#10;    print(&quot;-&quot; * 60)&#10;    &#10;    best_method, best_params = preview_run_optuna(&#10;        npy_array=npy_array,&#10;        settings=settings,&#10;        n_trials=50,            # Fewer trials for quick test&#10;        n_jobs=1&#10;    )&#10;    &#10;    return best_method, best_params&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Example usage:&#10;    # &#10;    # # Load your event data&#10;    # npy_array = np.load('path/to/your/event_data.npy')&#10;    # &#10;    # # Run optimization&#10;    # best_method, best_params = example_sequential(npy_array, settings)&#10;    # &#10;    # # Use the best parameters for actual candidate finding&#10;    # from HyperParameterSearch.findingSearch import get_function_from_name&#10;    # func = get_function_from_name(best_method)&#10;    # candidates, _ = func(npy_array, settings, **best_params)&#10;    # &#10;    # print(f&quot;Found {len(candidates)} candidates using optimized parameters!&quot;)&#10;    &#10;    print(&quot;Example script - replace with actual data loading and usage&quot;)&#10;    print(&quot;\nKey advantages of Optuna (Bayesian optimization) over grid search:&quot;)&#10;    print(&quot;1. More efficient: Explores parameter space intelligently&quot;)&#10;    print(&quot;2. Faster: Typically finds good parameters with fewer evaluations&quot;)&#10;    print(&quot;3. Adaptive: Learns from previous trials to focus on promising regions&quot;)&#10;    print(&quot;4. Handles continuous parameters better than discrete grid search&quot;)&#10;    print(&quot;\nTo use: Load your event data and call preview_run_optuna()&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test_color_scheme.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test_color_scheme.py" />
              <option name="updatedContent" value="&quot;&quot;&quot;&#10;Quick visual test for the Explore tab color scheme&#10;This shows what colors you should expect to see when using the Explore tab&#10;&quot;&quot;&quot;&#10;&#10;import matplotlib&#10;matplotlib.use('Agg')  # Use non-interactive backend&#10;import matplotlib.pyplot as plt&#10;import numpy as np&#10;from mpl_toolkits.mplot3d import Axes3D&#10;&#10;# Create figure&#10;fig = plt.figure(figsize=(14, 6))&#10;&#10;# Left subplot: Normal view&#10;ax1 = fig.add_subplot(121, projection='3d')&#10;ax1.set_title('Normal View (Before Selection)', fontsize=14, fontweight='bold')&#10;&#10;# Sample data for positive events&#10;pos_x = np.random.rand(50) * 10&#10;pos_y = np.random.rand(50) * 10&#10;pos_t = np.random.rand(50) * 10&#10;&#10;# Sample data for negative events&#10;neg_x = np.random.rand(50) * 10 + 5&#10;neg_y = np.random.rand(50) * 10&#10;neg_t = np.random.rand(50) * 10&#10;&#10;ax1.scatter(pos_x, pos_y, pos_t, c='#3498db', label='Positive events', alpha=0.6, s=30)&#10;ax1.scatter(neg_x, neg_y, neg_t, c='#e74c3c', label='Negative events', alpha=0.6, s=30)&#10;ax1.set_xlabel('X [px]')&#10;ax1.set_ylabel('Y [px]')&#10;ax1.set_zlabel('Time [ms]')&#10;ax1.legend()&#10;&#10;# Right subplot: Highlighted view&#10;ax2 = fig.add_subplot(122, projection='3d')&#10;ax2.set_title('After Selecting a Cluster', fontsize=14, fontweight='bold')&#10;&#10;# Cluster events (subset)&#10;cluster_pos_indices = [5, 6, 7, 8, 9]&#10;cluster_neg_indices = [5, 6, 7, 8, 9]&#10;&#10;# Background events (faded)&#10;bg_pos_x = np.delete(pos_x, cluster_pos_indices)&#10;bg_pos_y = np.delete(pos_y, cluster_pos_indices)&#10;bg_pos_t = np.delete(pos_t, cluster_pos_indices)&#10;&#10;ax2.scatter(bg_pos_x, bg_pos_y, bg_pos_t, c='#3498db', label='Other positive events', alpha=0.2, s=15)&#10;ax2.scatter(neg_x, neg_y, neg_t, c='#e74c3c', label='Other negative events', alpha=0.2, s=15)&#10;&#10;# Highlighted cluster (bright with yellow border)&#10;cluster_pos_x = pos_x[cluster_pos_indices]&#10;cluster_pos_y = pos_y[cluster_pos_indices]&#10;cluster_pos_t = pos_t[cluster_pos_indices]&#10;&#10;ax2.scatter(cluster_pos_x, cluster_pos_y, cluster_pos_t, &#10;           c='#00ff00', edgecolors='#ffff00', linewidths=2,&#10;           label='Selected cluster (pos)', alpha=1.0, s=80)&#10;&#10;ax2.set_xlabel('X [px]')&#10;ax2.set_ylabel('Y [px]')&#10;ax2.set_zlabel('Time [ms]')&#10;ax2.legend()&#10;&#10;plt.tight_layout()&#10;plt.savefig('/home/philippehenry/Documents/Master_DSAIT/0MastersThesis/EVE-software/explore_tab_color_scheme.png', dpi=150, bbox_inches='tight')&#10;print(&quot;Color scheme visualization saved to: explore_tab_color_scheme.png&quot;)&#10;print(&quot;\nColor Legend:&quot;)&#10;print(&quot;━&quot; * 60)&#10;print(&quot;NORMAL VIEW:&quot;)&#10;print(&quot;  • Positive events:    Blue (#3498db)&quot;)&#10;print(&quot;  • Negative events:    Red (#e74c3c)&quot;)&#10;print(&quot;\nAFTER SELECTION:&quot;)&#10;print(&quot;  • Background events:  Faded blue/red (20% opacity)&quot;)&#10;print(&quot;  • Selected cluster:&quot;)&#10;print(&quot;    - Positive:         Bright green (#00ff00)&quot;)&#10;print(&quot;    - Negative:         Bright magenta (#ff00ff)&quot;)&#10;print(&quot;    - Border:           Yellow (#ffff00)&quot;)&#10;print(&quot;━&quot; * 60)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>